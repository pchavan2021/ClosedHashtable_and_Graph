import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Arrays;

/**
 * @author pallucha21 and evanhowe03
 * @version 1.0
 */
public class Buffer {

    // an integer representing the index of the block
    // this record array is associated with
    private int buff;

    // array of records
    private Record[] data;
    private RandomAccessFile disk;
    private final static int BLOCK_SIZE = 4096/4;
    private long position; // postiton in the file
    private boolean isDirty;

    /**
     * construction
     * 
     * @param bufferSize
     *            this is the size
     */
    public Buffer(RandomAccessFile disk, int block) {
    
        data = new Record[BLOCK_SIZE];
        this.disk = disk;
        this.buff = block;
        this.isDirty = false;
        this.position = block % BLOCK_SIZE; // postion in file

    }


    /**
     * read lock
     * 
     * @return data
     */
    public Record[] readBlock() {

        return data;
    }

    /**
     * if the last spot is full return that record
     * if the the spot was empty return null;
     * @param rec
     * @return
     */
    public Record add(Record rec) {
        if(data[data.length - 1] != null) {
            return data[data.length - 1];
        }
        
        for (int i = 0; i < data.length; i++) {
            if (data[i] == null) {
                data[i] = rec;
                
            }
        }
        
        return null;
    }
    
    public short getKey(int index) {
        return data[index].getKey();
    }

    public short getValue(int index) {
        return data[index].getValue();
    }

    public void write(Record[] newData) {
        // Sets new data to the buffer and marks the buffer as dirty,
        // indicating that the buffer contents have been modified.
        data = newData;
        isDirty = true;

    }


    public void writeBack() throws IOException {
        /**
         * If the buffer is dirty (i.e., its data was modified),
         * it writes the buffer's data back to the disk at the appropriate
         * position.
         * This method also increments a counter named diskWrites in a separate
         * Stat class.
         */

        if (isDirty) {
            // write back and increment
            disk.seek(position); // should be current pos
            for (int x = 0; x < data.length; x++) {
                byte[] recordBytes = data[x].toByteArray();
                disk.write(recordBytes);
            }
            isDirty = false;
        }

    }


    public void diskRead() throws IOException {
        /**
         * Reads a block of data from the disk into the buffer.
         * It also increments a counter named diskReads in a separate Stat
         * class.
         */

        for (int i = 0; i < BLOCK_SIZE; i++) {
            byte[] recordBytes = new byte[4];

            disk.read(recordBytes);
            Record record = new Record();

            byte[] keyBytes = Arrays.copyOfRange(recordBytes, 0, 2);
            byte[] valueBytes = Arrays.copyOfRange(recordBytes, 2, 4);

            record.setKey(keyBytes);
            record.setValue(valueBytes);

            data[i] = record;
        }
    }


    public long block() {
        /**
         * Returns the block index associated with this buffer.
         */
        return position;
    }

}
