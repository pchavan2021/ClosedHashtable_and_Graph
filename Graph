import java.util.Arrays;

public class Graph<E> {

    private GraphNode[] graphArray;
    int graphSize;
    private int edgeCount;
    private int verticeCount;
    int[][] distances;

    // No real constructor needed
    public Graph(int n) {
        graphArray = new GraphNode[n];
        graphSize = n;
        edgeCount = 0;
        verticeCount = 0;

    }


    public int computeConnectedComponents(int[] parent) {
        Arrays.sort(parent);
        int uniqueCount = 0; // Start with 1 as there's at least one unique
                             // number
        for (int i = 1; i < parent.length; i++) {
            if (parent[i] != parent[i - 1]) {
                uniqueCount++; // Increment count for each new unique number
            }
        }

        return uniqueCount;
    }


    public int computeLargestConnectedComponent(int[] parent) {
        int largest = 0;/**
                         * for (int i = 0; i < parent.length; i++) {
                         * if (parent[i] != -1) {
                         * if (graphArray[i].getValue().size() > largest) {
                         * largest = graphArray[i].getValue().size();
                         * }
                         * }
                         * }
                         **/
        return largest;
    }


    public void print() {

        int[] parent = compute();

        /*
         * for (int y = 0; y < graphArray.length; y++) {
         * if (graphArray[y] != null) { // Check if the GraphNode is not null
         * System.out.println("Node at index " + y + ": "
         * + graphArray[y].getKey());
         * SinglyLinkedList<Integer> nodeValue = graphArray[y]
         * .getValue();
         * if (nodeValue != null) {
         * System.out.println("  Connections: " + nodeValue
         * .toString());
         * }
         * else {
         * System.out.println("  No connections.");
         * }
         * }
         * else {
         * System.out.println("Node at index " + y
         * + " is null.");
         * }
         * }
         */

        System.out.println("There are " + computeConnectedComponents(parent)
            + " connected components");

        int max = 0;
        int maxComponentSize = 0;
        for (int d = 0; d < parent.length; d++) {
            if (parent[d] >= 0) {
                if (graphArray[parent[d]].getValue().size() > max) {

                    int[] componentSizes = new int[graphSize];

                    for (int i = 0; i < parent.length; i++) {
                        if (parent[i] >= 0) {
                            int root = FIND(i, parent);
                            componentSizes[root]++;
                        }
                    }

                    maxComponentSize = 0;
                    for (int size : componentSizes) {
                        if (size > maxComponentSize) {
                            maxComponentSize = size;
                        }
                    }

                }

            }
        }
        if (maxComponentSize != 0) {
            maxComponentSize++;
        }
        System.out.println("The largest connected component has "
            + (maxComponentSize) + " elements");

        floydMaywether(); // Update distances matrix

        int diameter = 0;
        for (int i = 0; i < graphSize; i++) {
            for (int j = 0; j < graphSize; j++) {
                if (distances[i][j] != Integer.MAX_VALUE) {
                    diameter = Math.max(diameter, distances[i][j]);
                }
            }
        }

        System.out.println("The diameter of the largest component is "
            + diameter);

    }


    public void floydMaywether() {
        distances = new int[graphSize][graphSize];
        // Initialize distances for Floyd-Warshall
        for (int i = 0; i < graphSize; i++) {
            Arrays.fill(distances[i], Integer.MAX_VALUE);
            distances[i][i] = 0;
        }

        for (int i = 0; i < graphSize; i++) {
            if (graphArray[i] != null) {
                SinglyLinkedList<Integer> connections = graphArray[i]
                    .getValue();
                for (int index = 0; index < connections.size(); index++) {
                    int connection = connections.get(index);
                    distances[i][connection] = 1; // edge has weight 1
                }
            }
        }

        // Floyd-Warshall algorithm
        for (int k = 0; k < graphSize; k++) {
            for (int i = 0; i < graphSize; i++) {
                for (int j = 0; j < graphSize; j++) {
                    if (distances[i][k] < Integer.MAX_VALUE
                        && distances[k][j] < Integer.MAX_VALUE) {
                        distances[i][j] = Math.min(distances[i][j],
                            distances[i][k] + distances[k][j]);
                    }
                }
            }
        }
    }


    public int[] compute() {
        int parent[] = new int[graphSize];
        int weights[] = new int[graphSize];

        for (int i = 0; i < parent.length; i++) {
            parent[i] = -1;
        }

        for (int i = 0; i < weights.length; i++) {
            weights[i] = 1;
        }

        // Apply UNION
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                SinglyLinkedList<Integer> neighbors = graphArray[i].getValue();

                for (int j = 0; j < neighbors.size(); j++) {

                    if (FIND(i, parent) != FIND(neighbors.get(j), parent)) {
                        // System.out.println(sameComponent(i,
                        // neighbors.get(j)));
                        UNION(i, neighbors.get(j), parent, weights);
                    }
                }
            }
        }

        return parent;

    }


    // Merge two subtrees if they are different
    public void UNION(int a, int b, int[] parent, int[] weights) {
        int root1 = FIND(a, parent); // Find root of node a
        int root2 = FIND(b, parent); // Find root of node b
        if (root1 != root2) { // Merge with weighted union
            if (weights[root2] > weights[root1]) {
                parent[root1] = root2;
                weights[root2] += weights[root1];
            }
            else {
                parent[root2] = root1;
                weights[root1] += weights[root2];
            }
        }
    }


    // Return the root of curr's tree
    public int FIND(int curr, int[] parent) {
        while (parent[curr] != -1) {
            curr = parent[curr];
        }
        return curr; // Now at root
    }


    // Return the number of vertices
    public int verticeCount() {
        return verticeCount;
    }


    // Return the current number of edges
    public int totalEdgeCount() {

        return edgeCount;
    }


    // Get the value of node with index v
    public SinglyLinkedList getValue(int v) {
        return (SinglyLinkedList)graphArray[v].getValue();
    }


    // Set the value of node with index v
    public void setValue(int v, SinglyLinkedList val) {
        graphArray[v].setValue(val);
    }


    public void expandGraph() {
        int oldSize = graphSize;
        graphSize = graphSize * 2;

        GraphNode[] oldGraph = graphArray;

        graphArray = new GraphNode[graphSize];
        for (int i = 0; i < oldSize; i++) {
            graphArray[i] = oldGraph[i];
        }

    }


    public int getSize() {
        int count = 0;
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                count++;
            }
        }

        return count;
    }


    public void insert(String artistAdd, String songAdd) {
        int artistIndex = -1;
        int songIndex = -1;

        int count = getSize();

        if (count + 4 == graphArray.length) {
            System.out.println("i am doubling");
            expandGraph();
        }

        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                if (graphArray[i].getKey().equals(artistAdd)) {
                    artistIndex = i;
                    break;
                }
            }
        }

        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                if (graphArray[i].getKey().equals(songAdd)) {
                    songIndex = i;
                    break;
                }
            }
        }

        /**
         * if artist node and song node exists in the graph
         * add an edge between the two
         */
        if (artistIndex >= 0 && songIndex >= 0) {

            addEdge(artistIndex, songIndex);
        }
        else if (artistIndex >= 0 && songIndex < 0) {
            for (int i = 0; i < graphArray.length; i++) {
                if (graphArray[i] == null) {
                    songIndex = i;
                    GraphNode addSongNode = new GraphNode();
                    addSongNode.setKey(songAdd);
                    graphArray[i] = addSongNode;
                    break; // Stop after finding spot for song
                }
            }

            addEdge(artistIndex, songIndex);
        }
        else if (artistIndex < 0 && songIndex >= 0) {
            // Find next null spot for artist if not found
            for (int i = 0; i < graphArray.length; i++) {
                if (graphArray[i] == null) {
                    artistIndex = i;
                    GraphNode addArtistNode = new GraphNode();
                    addArtistNode.setKey(artistAdd);
                    graphArray[i] = addArtistNode;
                    break; // Stop after finding spot for artist
                }
            }

            addEdge(artistIndex, songIndex);

        }
        else if (artistIndex < 0 && songIndex < 0) {
            int a = -1000;
            int b = -1000;
            // neither the artist or song exist in the graph as nodes
            // add the artist and song nodes to the graoh
            // make the edges between them

            if (artistIndex == -1) {
                for (int i = 0; i < graphArray.length; i++) {
                    if (graphArray[i] == null) {
                        artistIndex = i;
                        a = i;

                        GraphNode addArtistNode = new GraphNode();
                        addArtistNode.setKey(artistAdd);
                        graphArray[i] = addArtistNode;

                        System.out.println(graphArray[i].getKey());
                        break; // Stop after finding spot for artist
                    }
                }
            }

            if (songIndex == -1) {
                for (int i = 0; i < graphArray.length; i++) {
                    if (graphArray[i] == null) {
                        songIndex = i;
                        b = i;

                        GraphNode addSongNode = new GraphNode();
                        addSongNode.setKey(songAdd);
                        graphArray[i] = addSongNode;

                        System.out.println(graphArray[i].getKey());
                        break; // Stop after finding spot for song
                    }
                }
            }
            addEdge(a, b);

        }
    }


    public void addVertex(GraphNode add) {
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] == null) {
                graphArray[i] = add;

                break;
            }
        }
    }


    // Adds a new edge from node v to node w
    public void addEdge(int v, int w) {
        SinglyLinkedList<Integer> songList = graphArray[v].getValue();
        SinglyLinkedList<Integer> artistList = graphArray[w].getValue();

        boolean isSongAdded = false;
        for (int i = 0; i < songList.size(); i++) {
            if (songList.get(i) != null && songList.get(i) == w) {
                // Duplicate found, do not add
                System.out.println("|" + graphArray[v].getKey() + "<SEP>"
                    + graphArray[w].getKey()
                    + "| duplicates a record already in the database.");
                isSongAdded = true;
                return;
            }
        }
        if (!isSongAdded) {
            songList.add(w); // Add only if not already present
            edgeCount++;
        }

        boolean isArtistAdded = false;
        for (int i = 0; i < artistList.size(); i++) {
            if (artistList.get(i) != null && artistList.get(i) == v) {
                // Duplicate found, do not add
                System.out.println("|" + graphArray[v].getKey() + "<SEP>"
                    + graphArray[w].getKey()
                    + "| duplicates a record already in the database.");
                isArtistAdded = true;
                return;
            }
        }
        if (!isArtistAdded) {
            artistList.add(v); // Add only if not already present
            edgeCount++;
        }
    }


    public void remove(String rem) {
        int index = -1;
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                if (graphArray[i].getKey() != null) {
                    if (graphArray[i].getKey().equals(rem)) {
                        index = i;
                        graphArray[i] = new GraphNode();
                        removeEdge(index);
                        verticeCount--;
                    }
                }
            }
        }
    }


    public void removeEdge(int rem) {
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                SinglyLinkedList<Integer> temp = graphArray[i].getValue();
                for (int j = 0; j < temp.size(); j++) {
                    if (temp.get(j) == rem) {
                        temp.remove(j);
                        edgeCount--;
                    }
                }
            }
        }
    }

    /**
     * 
     * // Removes the edge from the graph.
     * public void removeEdge(int v, int w) {
     * Edge curr = find(v, w);
     * if ((curr.next == null) || curr.next.vertex != w) {
     * return;
     * }
     * else {
     * curr.next = curr.next.next;
     * if (curr.next != null) {
     * curr.next.prev = curr;
     * }
     * }
     * numEdge--;
     * }
     * 
     * 
     * // Returns true iff the graph has the edge
     * public boolean hasEdge(int v, int w) {
     * return weight(v, w) != 0;
     * }
     * 
     * 
     * // Returns an array containing the indicies of the neighbors of v
     * public int[] neighbors(int v) {
     * int cnt = 0;
     * Edge curr;
     * for (curr = nodeArray[v].next; curr != null; curr = curr.next) {
     * cnt++;
     * }
     * int[] temp = new int[cnt];
     * cnt = 0;
     * for (curr = nodeArray[v].next; curr != null; curr = curr.next) {
     * temp[cnt++] = curr.vertex;
     * }
     * return temp;
     * }
     * 
     **/
}
