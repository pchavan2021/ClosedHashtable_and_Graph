import java.util.Arrays;
/**
 * @author Pallavi Chavan pallucha21 and evanhowe03
 * @version 1.0
 */
public class Graph<E> {

    private GraphNode<E>[] graphArray;
    int graphSize;
    int[][] distances;

    /**
     * graph constructor
     * @param n intial size of graph
     */
    public Graph(int n) {
        graphArray = new GraphNode[n];
        graphSize = n;

    }

    /**
     * compute # of connected components
     * @param parent
     * @return the count
     */
    public int computeConnectedComponents(int[] parent) {
        Arrays.sort(parent);
        int uniqueCount = 0; // Start with 1 as there's at least one unique
                             // number
        for (int i = 1; i < parent.length; i++) {
            if (parent[i] != parent[i - 1]) {
                uniqueCount++; // Increment count for each new unique number
            }
        }

        return uniqueCount;
    }

    /**
     * print method
     */
    public void print() {

        int[] parent = compute();

        for (int y = 0; y < graphArray.length; y++) {
            if (graphArray[y] != null) { // Check if the GraphNode is not null
                System.out.println("Node at index " + y + ": " + graphArray[y]
                    .getKey());
                SinglyLinkedList<Integer> nodeValue = graphArray[y].getValue();
                if (nodeValue != null) {
                    System.out.println("  Connections: " + nodeValue
                        .toString());
                }
                else {
                    System.out.println("  No connections.");
                }
            }
            else {
                System.out.println("Node at index " + y + " is null.");
            }
        }

        System.out.println("There are " + computeConnectedComponents(parent)
            + " connected components");

        int max = 0;
        int maxComponentSize = 0;
        for (int d = 0; d < parent.length; d++) {
            if (parent[d] >= 0) {
                if (graphArray[parent[d]].getValue().size() > max) {

                    int[] componentSizes = new int[graphSize];
                    int large = -1;
                    for (int i = 0; i < parent.length; i++) {
                        if (parent[i] >= 0) {
                            int root = FIND(i, parent);
                            componentSizes[root]++;
                            // do this here
                            if (componentSizes[root] > maxComponentSize) {
                                maxComponentSize = componentSizes[root];
                                large = root;
                            }
                        }
                    }

                    maxComponentSize = 0;
                    for (int size : componentSizes) {
                        if (size > maxComponentSize) {
                            maxComponentSize = size;
                        }
                    }

                }

            }
        }
        if (maxComponentSize != 0) {
            maxComponentSize++;
        }
        System.out.println("The largest connected component has "
            + (maxComponentSize) + " elements");

        int test = floydMaywether(); // Update distances matrix

        int diameter = 0;
        for (int i = 0; i < test; i++) {
            for (int j = 0; j < test; j++) {
                if (distances[i][j] != Integer.MAX_VALUE) {
                    diameter = Math.max(diameter, distances[i][j]);
                }
            }
        }

        System.out.println("The diameter of the largest component is "
            + diameter);

    }

    /**
     * compute diameter with
     *  floyd's algorithm
     * @return the diameter of largest
     * connected node
     */
    public int floydMaywether() {
        int[] largestComponentNodes = getLargestComponentNodes();
        int componentSize = largestComponentNodes.length;
        distances = new int[componentSize][componentSize];

        // Initialize distances
        for (int i = 0; i < componentSize; i++) {
            Arrays.fill(distances[i], Integer.MAX_VALUE);
            distances[i][i] = 0;
            int nodeIdx = largestComponentNodes[i];
            SinglyLinkedList<Integer> connections = graphArray[nodeIdx]
                .getValue();
            for (int j = 0; j < connections.size(); j++) {
                int connection = connections.get(j);
                for (int k = 0; k < largestComponentNodes.length; k++) {
                    if (largestComponentNodes[k] == connection) {
                        distances[i][k] = 1; // edge has weight 1
                        break;
                    }
                }
            }

        }

        // Apply Floyd-Warshall algorithm
        for (int k = 0; k < componentSize; k++) {
            for (int i = 0; i < componentSize; i++) {
                for (int j = 0; j < componentSize; j++) {
                    if (distances[i][k] < Integer.MAX_VALUE
                        && distances[k][j] < Integer.MAX_VALUE) {
                        distances[i][j] = Math.min(distances[i][j],
                            distances[i][k] + distances[k][j]);
                    }
                }
            }
        }
        return largestComponentNodes.length;
    }

    /**
     * use the union/find algorithm to create
     * the parent array
     * @return the parent array
     */
    public int[] compute() {
        int parent[] = new int[graphSize];
        int weights[] = new int[graphSize];

        for (int i = 0; i < parent.length; i++) {
            parent[i] = -1;
        }

        for (int i = 0; i < weights.length; i++) {
            weights[i] = 1;
        }

        // Apply UNION
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                SinglyLinkedList<Integer> neighbors = graphArray[i].getValue();

                for (int j = 0; j < neighbors.size(); j++) {

                    if (FIND(i, parent) != FIND(neighbors.get(j), parent)) {
                        // System.out.println(sameComponent(i,
                        // neighbors.get(j)));
                        UNION(i, neighbors.get(j), parent, weights);
                    }
                }
            }
        }

        return parent;

    }


    /**
     * merge two subtrees if theyre different
     * @param a index of root of first node
     * @param b index of root of 2nd node
     * @param parent parent array
     * @param weights weights array
     */
    public void UNION(int a, int b, int[] parent, int[] weights) {
        int root1 = FIND(a, parent); // Find root of node a
        int root2 = FIND(b, parent); // Find root of node b
        if (root1 != root2) { // Merge with weighted union
            if (weights[root2] > weights[root1]) {
                parent[root1] = root2;
                weights[root2] += weights[root1];
            }
            else {
                parent[root2] = root1;
                weights[root1] += weights[root2];
            }
        }
    }


    /**
     * Return the root of curr's tree
     * @param curr current node
     * @param parent parent array
     * @return index of root node
     */
    public int FIND(int curr, int[] parent) {
        while (parent[curr] != -1) {
            curr = parent[curr];
        }
        return curr; // Now at root
    }
    
    /**
     * expand the graph
     */
    public void expandGraph() {
        int oldSize = graphSize;
        graphSize = graphSize * 2;

        GraphNode<E>[] oldGraph = graphArray;

        graphArray = new GraphNode[graphSize];
        for (int i = 0; i < oldSize; i++) {
            graphArray[i] = oldGraph[i];
        }

    }

    /**
     * find the size of the graph
     * @return the size
     */
    public int getSize() {
        int count = 0;
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                count++;
            }
        }

        return count;
    }

    /**
     * insert song and artist
     * @param artistAdd string
     * @param songAdd string
     */
    public void insert(String artistAdd, String songAdd) {
        int artistIndex = -1;
        int songIndex = -1;

        int count = getSize();

        if (count >= graphSize * 0.75) {

            expandGraph();
        }
        // MAYBE ERRORING ON THIS
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                if (graphArray[i].getKey().equals(artistAdd)) {
                    artistIndex = i;
                    break;
                }
            }
        }

        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                if (graphArray[i].getKey().equals(songAdd)) {
                    songIndex = i;
                    break;
                }
            }
        }

        /**
         * if artist node and song node exists in the graph
         * add an edge between the two
         */
        if (artistIndex >= 0 && songIndex >= 0) {

            addEdge(artistIndex, songIndex);
        }
        else if (artistIndex >= 0 && songIndex < 0) {
            for (int i = 0; i < graphArray.length; i++) {
                if (graphArray[i] == null) {
                    songIndex = i;
                    GraphNode<E> addSongNode = new GraphNode<E>();
                    addSongNode.setKey(songAdd);
                    graphArray[i] = addSongNode;
                    break; // Stop after finding spot for song
                }
            }

            addEdge(artistIndex, songIndex);
        }
        else if (artistIndex < 0 && songIndex >= 0) {
            // Find next null spot for artist if not found
            for (int i = 0; i < graphArray.length; i++) {
                if (graphArray[i] == null) {
                    artistIndex = i;
                    GraphNode<E> addArtistNode = new GraphNode<E>();
                    addArtistNode.setKey(artistAdd);
                    graphArray[i] = addArtistNode;
                    break; // Stop after finding spot for artist
                }
            }

            addEdge(artistIndex, songIndex);

        }
        else if (artistIndex < 0 && songIndex < 0) {
            int a = -1000;
            int b = -1000;
            // neither the artist or song exist in the graph as nodes
            // add the artist and song nodes to the graoh
            // make the edges between them

            if (artistIndex == -1) {
                for (int i = 0; i < graphArray.length; i++) {
                    if (graphArray[i] == null) {
                        artistIndex = i;
                        a = i;

                        GraphNode<E> addArtistNode = new GraphNode<E>();
                        addArtistNode.setKey(artistAdd);
                        graphArray[i] = addArtistNode;
                        break; // Stop after finding spot for artist
                    }

                }
            }

            if (songIndex == -1) {
                for (int i = 0; i < graphArray.length; i++) {
                    if (graphArray[i] == null) {
                        songIndex = i;
                        b = i;

                        GraphNode<E> addSongNode = new GraphNode<E>();
                        addSongNode.setKey(songAdd);
                        graphArray[i] = addSongNode;
                        break; // Stop after finding spot for song
                    }
                }
            }
            addEdge(a, b);

        }
    }

    /**
     * add a graph node
     * @param add graph node
     */
    public void addVertex(GraphNode<E> add) {
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] == null) {
                graphArray[i] = add;

                break;
            }
        }
    }


    /**
     * Adds a new edge from node v to node w
     * @param v artist indice
     * @param w song indice
     */
    public void addEdge(int v, int w) {
        SinglyLinkedList<Integer> songList = graphArray[v].getValue();
        SinglyLinkedList<Integer> artistList = graphArray[w].getValue();

        boolean isSongAdded = false;
        for (int i = 0; i < songList.size(); i++) {
            if (songList.get(i) != null && songList.get(i) == w) {
                // Duplicate found, do not add
                System.out.println("|" + graphArray[v].getKey() + "<SEP>"
                    + graphArray[w].getKey()
                    + "| duplicates a record already in the database.");
                isSongAdded = true;
                return;
            }
        }
        if (!isSongAdded) {
            songList.add(w); // Add only if not already present
   
        }

        boolean isArtistAdded = false;
        for (int i = 0; i < artistList.size(); i++) {
            if (artistList.get(i) != null && artistList.get(i) == v) {
                // Duplicate found, do not add
                System.out.println("|" + graphArray[v].getKey() + "<SEP>"
                    + graphArray[w].getKey()
                    + "| duplicates a record already in the database.");
                isArtistAdded = true;
                return;
            }
        }
        if (!isArtistAdded) {
            artistList.add(v); // Add only if not already present
         
        }
    }

    /**
     * delte a node and it's edges
     * @param rem artist/song to remove
     */
    public void remove(String rem) {
        int index = -1;
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {

                if (graphArray[i].getKey().equals(rem)) {
                    index = i;
                    graphArray[i] = null;
                    removeEdge(index);
                }

            }
        }
    }

    /**
     * remove the indicated edge
     * @param rem the 
     * node to be removed
     */
    public void removeEdge(int rem) {
        for (int i = 0; i < graphArray.length; i++) {
            if (graphArray[i] != null) {
                SinglyLinkedList<Integer> temp = graphArray[i].getValue();
                for (int j = 0; j < temp.size(); j++) {
                    if (temp.get(j) == rem) {
                        temp.remove(j);
                    }
                }
            }
        }
    }

    /**
     * get the # nodes of 
     * the largest component
     * @return int array
     */
    public int[] getLargestComponentNodes() {
        int[] parent = compute();
        int[] componentSizes = new int[graphSize];
        int largestComponentRoot = -1;
        int maxComponentSize = 0;

        // Find root of each node and count the size of each component
        for (int i = 0; i < graphSize; i++) {
            if (graphArray[i] != null) {
                int root = FIND(i, parent);
                componentSizes[root]++;
                if (componentSizes[root] > maxComponentSize) {
                    maxComponentSize = componentSizes[root];
                    largestComponentRoot = root;
                }
            }
        }

        // Collect nodes in the largest component
        int[] largestComponentNodes = new int[maxComponentSize];
        int index = 0;
        for (int i = 0; i < graphSize; i++) {
            if (FIND(i, parent) == largestComponentRoot) {
                largestComponentNodes[index++] = i;
            }
        }

        return largestComponentNodes;
    }

}
