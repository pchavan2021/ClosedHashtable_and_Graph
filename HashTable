/**
 * @author Pallavi Chavan pallucha21 and Evan Howe evanhowe03
 * @param <K>
 *            this is the key
 * @param <V>
 *            this is the value
 * @version 09/14/23
 */
public class HashTable<K, V> {
    private int hashSize; // hash
    private int size; // size
    private Node[] table; // tab;e
    private Hash compute;
    private boolean song;

    /**
     * HashTable constructor
     * 
     * @param initialHashSize
     *            this is the size of the hash table
     */
    public HashTable(int initialHashSize, boolean which) {

        song = which;
        hashSize = initialHashSize;
        size = 0;
        table = new Node[hashSize];
        compute = new Hash();

    }


    /**
     * return the size of the hash table
     */
    public int getHashSize() {
        return hashSize;
    }


    /**
     * public int sfold(String s, int M) {
     * long sum = 0, mul = 1;
     * for (int i = 0; i < s.length(); i++) {
     * mul = (i % 4 == 0) ? 1 : mul * 256;
     * sum += s.charAt(i) * mul;
     * }
     * return (int)(Math.abs(sum) % M);
     * }
     **/

    /**
     * this doubles the hashtable by creating an empt y hashtable that's double
     * the
     * initial size and rehashing all of the old val ues of the old table into
     * the
     * new one
     */
    private void doubleTable() {
        // the size of the hashTable now
        int oldSize = hashSize;
        // a copy of the table now
        Node[] oldTable = table;

        hashSize = hashSize * 2;
        // the now hashtable
        // has double the capacity
        table = new Node[hashSize];

        // Rehash all existing entries into the new table
        for (int i = 0; i < oldSize; i++) {
            if (oldTable[i] != null) {

                int hash1 = compute.h(oldTable[i].key, hashSize);

                table[hash1] = oldTable[i];

            }

        }

    }


    /**
     * 
     * @param key
     *            this represents the key value
     * @param value
     *            this the seminar
     * @param hand
     *            this is the associated handle that you'll u se in the
     *            memManager
     * @return a true if the artist is already in the hashtable
     * @throws Exception
     */
    public boolean insert(K key, V value, String temp)
        throws Exception {

        // doubles the table if the table is more than %50 full
        if (size >= (hashSize / 2)) {
            doubleTable();
            
            if (song) {
                System.out.println("Song hash table size doubled.");
            }
            else {
                System.out.println("Artist hash table size doubled.");
            }
            
        }

        // creating hashing values based on key
        int hashing1 = compute.h(key, hashSize);
     
        int i = 0;
        
        while (i < hashSize) {
            int probe = (hash + i * i) % capacity;
            Node<K, V> entry = table[probe];
            
            if (entry == null || entry.isDeleted) {
                table[probe] = new Node<>(key, value);
                size++;
              
            } else if (entry.key.equals(key)) {
                if (song) {
                    System.out.println("|" + temp + "<SEP>" + key
                        + "| duplicates a record already in the database.");
                    return false;
                }
                else {
                    System.out.println("|" + key + "<SEP>" + temp
                        + "| duplicates a record already in the database.");
                    return true;

                }
            }

            i++;
        
        


    }
    // assign the spot in the hashtable to the new entry
    table[hashing1]=new Node(key,value,false);

    size++;

    if(song)
    {
        System.out.println("|" + key + "| is added to the Song database.");
    }else
    {
        System.out.println("|" + key + "| is added to the Artist database.");
    }

    }

    /**
     * Deletes a seminar from the hashtable
     * 
     * @param key
     *            this the key value
     * @return whether the deletion was successful or not
     */
    public boolean delete(int key) {
        // retreive the hashtable index
        int index = findIndex(key);

        // if the record doesn't exist
        if (index == -1) {

            System.out.println("Delete FAILED -- " + "There is no reco"
                + "rd with ID " + key);
            return false;

        } // if there is a record with that key
        else if (table[index].key == key) {

            table[index].tomb = true;
            size--;
            System.out.println("Record with ID " + key + " successfu"
                + "lly deleted from the database");
            table[index].value = null;

        }
        return true;

    }


    /**
     * searches for the seminar by it's key
     * 
     * @param key
     *            this is the key you're searching for
     */
    public boolean search(int key) {

        int index = findIndex(key);

        if (index == -1 || table[index].tomb) {
            System.out.println("Search FAILED -- There is no re" + "co"
                + "rd with ID " + key);
            return false;

        }
        else if (table[index].key == key && table[index] != null) {
            if (table[index].value != null) {
                System.out.println("Found record with ID " + table[index].key
                    + ":");
                System.out.println(table[index].value.toString());
            }
            else {
                System.out.println("Search FAILED --" + " There"
                    + " is no record with ID " + key);
                return true;

            }

        }
        return true;
    }


    public boolean searchTest(int key) {

        int index = findIndex(key);

        if (index == -1 || table[index].tomb) {
            // System.out.println("Search FAILED -- There is no re" + "co" + "rd
            // with ID " + key);
            return false;

        }
        else if (table[index].key == key && table[index] != null) {
            if (table[index].value != null) {
                // System.out.println("Found record with ID " + table[index].key
                // + ":");
                // System.out.println(table[index].value.toString());
            }
            else {
                // System.out.println("Search FAILED --" + " There" + " is no
                // record with ID " + key);
                return true;

            }

        }
        return true;
    }


    /**
     * Returns the seminar by it's key
     * 
     * @param key
     *            this the key you're looking for
     * @return the Seminar associate with the key
     */
    public Seminar searchAndReturn(int key) {

        int index = findIndex(key);
        if (index == -1) {
            return null;
        }
        else {
            return (table[index].value);
        }

    }


    /**
     * Find the hashing index for the key
     * 
     * @param key
     *            this
     * @return the hashing index
     */
    public int findIndex(int key) {
        // first hashing value
        int hash = compute.h(key, hashSize);

        int i = 0;

        while (table[hashing1] != null && i < hashSize) {

            if (table[hashing1].key == key) {
                return hashing1;
            }
            hashing1 = (hashing1 + hashing2) % table.length;
            i++;

        }

        return -1; // key not found

    }


    /**
     * 
     * @param printmythingy
     *            take in the string "hashtable" or "blocks"
     * @return whether it was requested to print blocks or hashtable
     */
    public boolean print(String printmythingy) {
        if (printmythingy.equalsIgnoreCase("hashtable")) {
            System.out.println("Hashtable:");
            for (int x = 0; x < hashSize; x++) {
                if (table[x] != null) {

                    if (table[x].tomb) {
                        System.out.println("" + x + ": " + "TOMBSTONE");
                    }
                    else {

                        System.out.println("" + x + ": " + table[x].key + "");

                    }

                }
            }

            System.out.println("total records: " + size);
        }

        if (printmythingy.equalsIgnoreCase("blocks")) {
            System.out.println("FreeBlockList:");
            return true;
        }

        return false;

    }
}
