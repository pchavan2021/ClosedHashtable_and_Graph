/**
 * @author Pallavi Chavan pallucha21 and Evan Howe evanhowe03
 * @param <K>
 *            this is the key
 * @param <V>
 *            this is the value
 * @version 09/14/23
 */
public class HashTable<K, V> {
    private int hashSize; // hash
    private int size; // size
    private Node[] table; // tab;e
    private Hash compute;
    private boolean song;

    /**
     * HashTable constructor
     * 
     * @param initialHashSize
     *            this is the size of the hash table
     */
    public HashTable(int initialHashSize, boolean which) {

        song = which;
        hashSize = initialHashSize;
        size = 0;
        table = new Node[hashSize];
        compute = new Hash();

    }


    /**
     * return the size of the hash table
     */
    public int getHashSize() {
        return hashSize;
    }


    /**
     * public int sfold(String s, int M) {
     * long sum = 0, mul = 1;
     * for (int i = 0; i < s.length(); i++) {
     * mul = (i % 4 == 0) ? 1 : mul * 256;
     * sum += s.charAt(i) * mul;
     * }
     * return (int)(Math.abs(sum) % M);
     * }
     **/

    /**
     * this doubles the hashtable by creating an empt y hashtable that's double
     * the
     * initial size and rehashing all of the old val ues of the old table into
     * the
     * new one
     */
    private void doubleTable() {
        // Save the old hash table and its size
        Node[] oldTable = table;
        int oldSize = hashSize;

        // Double the size of the hash table
        hashSize *= 2;
        table = new Node[hashSize];

        // Reset size to 0 since it will be recalculated during rehashing
        size = 0;

        // Rehash all non-null and non-deleted nodes
        for (int i = 0; i < oldSize; i++) {
            if (oldTable[i] != null && !oldTable[i].isDeleted()) {
                try {
                    // Reinsert using the insert method to handle hashing and
                    // collision

                    insert(oldTable[i].getKey(), oldTable[i]
                        .getValue(), oldTable[i].getKey(), true);
                }
                catch (Exception e) {
                    // Handle any exceptions that may occur during reinsertion
                    e.printStackTrace();
                }
            }
        }
    }


    /**
     * 
     * @param key
     *            this represents the key value
     * @param value
     *            this the seminar
     * @param hand
     *            this is the associated handle that you'll u se in the
     *            memManager
     * @return a true if the artist is already in the hashtable
     * @throws Exception
     */
    /**
     * 
     * @param key
     *            this represents the key value
     * @param value
     *            this the seminar
     * @param hand
     *            this is the associated handle that you'll u se in the
     *            memManager
     * @return a true if the artist is already in the hashtable
     * @throws Exception
     */
    public boolean insert(K key, V value, String temp, boolean fish)
        throws Exception {
        // Check if resizing is needed
        if (size >= (hashSize / 2)) {
            doubleTable();
            if (song) {
                System.out.println("Song hash table size doubled.");
            }
            else {
                System.out.println("Artist hash table size doubled.");
            }
        }

        // Hash the key to get the initial index
        int hash = Hash.h((String)key, hashSize);
        int i = 0;

        while (i < hashSize) {
            int probe = (hash + i * i) % hashSize;
            Node<K, V> entry = table[probe];

            // If the spot is empty or marked for deletion, insert the new node
            if (entry == null || entry.isDeleted()) {
                table[probe] = new Node<>(key, value);
                size++;
                if (song) {
                    System.out.println("|" + key + "|"
                        + " is added to the Song database.");
                    table[probe].setTomb(false);
                }
                else {
                    System.out.println("|" + key + "|"
                        + " is added to the Artist database.");
                    table[probe].setTomb(false);
                }
                return true;
            }

            // Check for duplicate keys
            else if (entry.key.equals(key) && !fish) {
                if (song && entry.value.equals(value)) {
                    System.out.println("|" + value + "<SEP>" + key
                        + "| duplicates a record already in the Song database.");
                }
                if (temp.equalsIgnoreCase("insert")) {
                    table[probe] = new Node<>(key, value);
                    table[probe].setTomb(false);
                    System.out.println("|" + key + "|"
                        + " is added to the Song database.");
                }
                return false;
            }

            i++;
        }

        throw new Exception("HashTable is full");
    }


    /**
     * Deletes a seminar from the hashtable
     * 
     * @param key
     *            this the key value
     * @return whether the deletion was successful or not
     */
    public boolean delete(K key) {

        int index = findIndex(key);

        if (index == -1) {
            if (song) {
                System.out.println("|" + key
                    + "| does not exist in the Song database.");
            }
            else {
                System.out.println("|" + key
                    + "| does not exist in the Artist database.");
            }

            return false;
        }

        Node<K, V> entry = table[index];
        if (entry.key.equals(key) && !entry.isDeleted()) {
            table[index].setTomb(true);
            size--;
            if (song) {
                System.out.println("|" + key
                    + "| is removed from the Song databse.");
            }
            else {
                System.out.println("|" + key
                    + "| is removed from the Artist databse.");
            }

            return true;
        }

        return false;
    }


    /**
     * searches for the seminar by it's key
     * 
     * @param key
     *            this is the key you're searching for
     */
    /**
     * public boolean search(int key) {
     * 
     * int index = findIndex(key);
     * 
     * if (index == -1 || table[index].tomb) {
     * System.out.println("Search FAILED -- There is no re"
     * + "co" + "rd with ID " + key);
     * return false;
     * 
     * }
     * else if (table[index].key == key && table[index] != null) {
     * if (table[index].value != null) {
     * System.out.println("Found record with ID "
     * + table[index].key + ":");
     * System.out.println(table[index].value.toString());
     * }
     * else {
     * System.out.println("Search FAILED --" + " There"
     * + " is no record with ID " + key);
     * return true;
     * 
     * }
     * 
     * }
     * return true;
     * }
     **/

    /**
     * Returns the seminar by it's key
     * 
     * @param key
     *            this the key you're looking for
     * @return the Seminar associate with the key
     */

    /**
     * Find the hashing index for the key
     * 
     * @param key
     *            this
     * @return the hashing index
     */
    public int findIndex(K key) {
        int hash1 = Hash.h((String)key, hashSize);
        int i = 0;

        while (i < hashSize) {
            int probe = (hash1 + i * i) % hashSize;
            Node<K, V> entry = table[probe];

            if (entry == null) {
                return -1;
            }
            else if (!entry.tomb && entry.key.equals(key)) {
                return probe;

            }
            i++;

        }
        return -1;
    }


    /**
     * 
     * @param printmythingy
     *            take in the string "hashtable" or "blocks"
     * @return whether it was requested to print blocks or hashtable
     */
    public int print() {

        for (int x = 0; x < hashSize; x++) {
            if (table[x] != null) {
                if (table[x].tomb) {
                    System.out.println("" + x + ": TOMBSTONE");
                }
                else {
                    System.out.println("" + x + ": |" + table[x].key
                        + "|");
                }
            }

        }

        return size;

    }
}
